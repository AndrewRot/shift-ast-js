// Generated by src/generate-checked.js.

/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function isNotExpression(node) {
  return node === undefined || (node.type !== 'ArrayExpression') && (node.type !== 'ArrowExpression') && (node.type !== 'AssignmentExpression') && (node.type !== 'BinaryExpression') && (node.type !== 'CallExpression') && (node.type !== 'ClassExpression') && (node.type !== 'CompoundAssignmentExpression') && (node.type !== 'ConditionalExpression') && (node.type !== 'FunctionExpression') && (node.type !== 'IdentifierExpression') && (node.type !== 'LiteralBooleanExpression') && (node.type !== 'LiteralInfinityExpression') && (node.type !== 'LiteralNullExpression') && (node.type !== 'LiteralNumericExpression') && (node.type !== 'LiteralRegExpExpression') && (node.type !== 'LiteralStringExpression') && ((node.type !== 'ComputedMemberExpression') && (node.type !== 'StaticMemberExpression')) && (node.type !== 'NewExpression') && (node.type !== 'NewTargetExpression') && (node.type !== 'ObjectExpression') && (node.type !== 'TemplateExpression') && (node.type !== 'ThisExpression') && (node.type !== 'UnaryExpression') && (node.type !== 'UpdateExpression') && (node.type !== 'YieldExpression') && (node.type !== 'YieldGeneratorExpression');
}

function isNotStatement(node) {
  return node === undefined || (node.type !== 'BlockStatement') && (node.type !== 'BreakStatement') && (node.type !== 'ClassDeclaration') && (node.type !== 'ContinueStatement') && (node.type !== 'DebuggerStatement') && (node.type !== 'EmptyStatement') && (node.type !== 'ExpressionStatement') && (node.type !== 'FunctionDeclaration') && (node.type !== 'IfStatement') && ((node.type !== 'DoWhileStatement') && (node.type !== 'ForInStatement') && (node.type !== 'ForOfStatement') && (node.type !== 'ForStatement') && (node.type !== 'WhileStatement')) && (node.type !== 'LabeledStatement') && (node.type !== 'ReturnStatement') && (node.type !== 'SwitchStatement') && (node.type !== 'SwitchStatementWithDefault') && (node.type !== 'ThrowStatement') && (node.type !== 'TryCatchStatement') && (node.type !== 'TryFinallyStatement') && (node.type !== 'VariableDeclarationStatement') && (node.type !== 'WithStatement');
}

export class ArrayAssignmentTarget {
  constructor({elements, rest}) {
    if (elements === undefined || !Array.isArray(elements) || elements.some(f => f === undefined || f !== null && ((f.type !== 'AssignmentTargetWithDefault') && (((f.type !== 'ArrayAssignmentTarget') && (f.type !== 'ObjectAssignmentTarget')) && ((f.type !== 'AssignmentTargetIdentifier') && ((f.type !== 'ComputedMemberAssignmentTarget') && (f.type !== 'StaticMemberAssignmentTarget'))))))) {
      throw new TypeError('Field "elements" of ArrayAssignmentTarget constructor is of incorrect type (expected [null or one of {AssignmentTargetWithDefault, ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}])');
    }
    if (rest === undefined || rest !== null && (((rest.type !== 'ArrayAssignmentTarget') && (rest.type !== 'ObjectAssignmentTarget')) && ((rest.type !== 'AssignmentTargetIdentifier') && ((rest.type !== 'ComputedMemberAssignmentTarget') && (rest.type !== 'StaticMemberAssignmentTarget'))))) {
      throw new TypeError('Field "rest" of ArrayAssignmentTarget constructor is of incorrect type (expected null or one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget})');
    }
    this.type = 'ArrayAssignmentTarget';
    this.elements = elements;
    this.rest = rest;
  }
}

export class ArrayBinding {
  constructor({elements, rest}) {
    if (elements === undefined || !Array.isArray(elements) || elements.some(f => f === undefined || f !== null && ((f.type !== 'BindingWithDefault') && ((f.type !== 'BindingIdentifier') && ((f.type !== 'ArrayBinding') && (f.type !== 'ObjectBinding')))))) {
      throw new TypeError('Field "elements" of ArrayBinding constructor is of incorrect type (expected [null or one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}])');
    }
    if (rest === undefined || rest !== null && ((rest.type !== 'BindingIdentifier') && ((rest.type !== 'ArrayBinding') && (rest.type !== 'ObjectBinding')))) {
      throw new TypeError('Field "rest" of ArrayBinding constructor is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding})');
    }
    this.type = 'ArrayBinding';
    this.elements = elements;
    this.rest = rest;
  }
}

export class ArrayExpression {
  constructor({elements}) {
    if (elements === undefined || !Array.isArray(elements) || elements.some(f => f === undefined || f !== null && ((isNotExpression(f)) && (f.type !== 'SpreadElement')))) {
      throw new TypeError('Field "elements" of ArrayExpression constructor is of incorrect type (expected [null or one of {Expression, SpreadElement}])');
    }
    this.type = 'ArrayExpression';
    this.elements = elements;
  }
}

export class ArrowExpression {
  constructor({params, body}) {
    if (params === undefined || params.type !== 'FormalParameters') {
      throw new TypeError('Field "params" of ArrowExpression constructor is of incorrect type (expected FormalParameters)');
    }
    if (body === undefined || (isNotExpression(body)) && (body.type !== 'FunctionBody')) {
      throw new TypeError('Field "body" of ArrowExpression constructor is of incorrect type (expected one of {Expression, FunctionBody})');
    }
    this.type = 'ArrowExpression';
    this.params = params;
    this.body = body;
  }
}

export class AssignmentExpression {
  constructor({binding, expression}) {
    if (binding === undefined || ((binding.type !== 'ArrayAssignmentTarget') && (binding.type !== 'ObjectAssignmentTarget')) && ((binding.type !== 'AssignmentTargetIdentifier') && ((binding.type !== 'ComputedMemberAssignmentTarget') && (binding.type !== 'StaticMemberAssignmentTarget')))) {
      throw new TypeError('Field "binding" of AssignmentExpression constructor is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget})');
    }
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of AssignmentExpression constructor is of incorrect type (expected Expression)');
    }
    this.type = 'AssignmentExpression';
    this.binding = binding;
    this.expression = expression;
  }
}

export class AssignmentTargetIdentifier {
  constructor({name}) {
    if (name === undefined || typeof name !== 'string') {
      throw new TypeError('Field "name" of AssignmentTargetIdentifier constructor is of incorrect type (expected string)');
    }
    this.type = 'AssignmentTargetIdentifier';
    this.name = name;
  }
}

export class AssignmentTargetPropertyIdentifier {
  constructor({binding, init}) {
    if (binding === undefined || binding.type !== 'AssignmentTargetIdentifier') {
      throw new TypeError('Field "binding" of AssignmentTargetPropertyIdentifier constructor is of incorrect type (expected AssignmentTargetIdentifier)');
    }
    if (init === undefined || init !== null && (isNotExpression(init))) {
      throw new TypeError('Field "init" of AssignmentTargetPropertyIdentifier constructor is of incorrect type (expected null or Expression)');
    }
    this.type = 'AssignmentTargetPropertyIdentifier';
    this.binding = binding;
    this.init = init;
  }
}

export class AssignmentTargetPropertyProperty {
  constructor({name, binding}) {
    if (name === undefined || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {
      throw new TypeError('Field "name" of AssignmentTargetPropertyProperty constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName})');
    }
    if (binding === undefined || (binding.type !== 'AssignmentTargetWithDefault') && (((binding.type !== 'ArrayAssignmentTarget') && (binding.type !== 'ObjectAssignmentTarget')) && ((binding.type !== 'AssignmentTargetIdentifier') && ((binding.type !== 'ComputedMemberAssignmentTarget') && (binding.type !== 'StaticMemberAssignmentTarget'))))) {
      throw new TypeError('Field "binding" of AssignmentTargetPropertyProperty constructor is of incorrect type (expected one of {AssignmentTargetWithDefault, ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget})');
    }
    this.type = 'AssignmentTargetPropertyProperty';
    this.name = name;
    this.binding = binding;
  }
}

export class AssignmentTargetWithDefault {
  constructor({binding, init}) {
    if (binding === undefined || ((binding.type !== 'ArrayAssignmentTarget') && (binding.type !== 'ObjectAssignmentTarget')) && ((binding.type !== 'AssignmentTargetIdentifier') && ((binding.type !== 'ComputedMemberAssignmentTarget') && (binding.type !== 'StaticMemberAssignmentTarget')))) {
      throw new TypeError('Field "binding" of AssignmentTargetWithDefault constructor is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget})');
    }
    if (isNotExpression(init)) {
      throw new TypeError('Field "init" of AssignmentTargetWithDefault constructor is of incorrect type (expected Expression)');
    }
    this.type = 'AssignmentTargetWithDefault';
    this.binding = binding;
    this.init = init;
  }
}

export class BinaryExpression {
  constructor({left, operator, right}) {
    if (isNotExpression(left)) {
      throw new TypeError('Field "left" of BinaryExpression constructor is of incorrect type (expected Expression)');
    }
    if (operator === undefined || ["==","!=","===","!==","<","<=",">",">=","in","instanceof","<<",">>",">>>","+","-","*","/","%","**",",","||","&&","|","^","&"].indexOf(operator) === -1) {
      throw new TypeError('Field "operator" of BinaryExpression constructor is of incorrect type (expected one of {"==", "!=", "===", "!==", "<", "<=", ">", ">=", "in", "instanceof", "<<", ">>", ">>>", "+", "-", "*", "/", "%", "**", ",", "||", "&&", "|", "^", "&"})');
    }
    if (isNotExpression(right)) {
      throw new TypeError('Field "right" of BinaryExpression constructor is of incorrect type (expected Expression)');
    }
    this.type = 'BinaryExpression';
    this.left = left;
    this.operator = operator;
    this.right = right;
  }
}

export class BindingIdentifier {
  constructor({name}) {
    if (name === undefined || typeof name !== 'string') {
      throw new TypeError('Field "name" of BindingIdentifier constructor is of incorrect type (expected string)');
    }
    this.type = 'BindingIdentifier';
    this.name = name;
  }
}

export class BindingPropertyIdentifier {
  constructor({binding, init}) {
    if (binding === undefined || binding.type !== 'BindingIdentifier') {
      throw new TypeError('Field "binding" of BindingPropertyIdentifier constructor is of incorrect type (expected BindingIdentifier)');
    }
    if (init === undefined || init !== null && (isNotExpression(init))) {
      throw new TypeError('Field "init" of BindingPropertyIdentifier constructor is of incorrect type (expected null or Expression)');
    }
    this.type = 'BindingPropertyIdentifier';
    this.binding = binding;
    this.init = init;
  }
}

export class BindingPropertyProperty {
  constructor({name, binding}) {
    if (name === undefined || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {
      throw new TypeError('Field "name" of BindingPropertyProperty constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName})');
    }
    if (binding === undefined || (binding.type !== 'BindingWithDefault') && ((binding.type !== 'BindingIdentifier') && ((binding.type !== 'ArrayBinding') && (binding.type !== 'ObjectBinding')))) {
      throw new TypeError('Field "binding" of BindingPropertyProperty constructor is of incorrect type (expected one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding})');
    }
    this.type = 'BindingPropertyProperty';
    this.name = name;
    this.binding = binding;
  }
}

export class BindingWithDefault {
  constructor({binding, init}) {
    if (binding === undefined || (binding.type !== 'BindingIdentifier') && ((binding.type !== 'ArrayBinding') && (binding.type !== 'ObjectBinding'))) {
      throw new TypeError('Field "binding" of BindingWithDefault constructor is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding})');
    }
    if (isNotExpression(init)) {
      throw new TypeError('Field "init" of BindingWithDefault constructor is of incorrect type (expected Expression)');
    }
    this.type = 'BindingWithDefault';
    this.binding = binding;
    this.init = init;
  }
}

export class Block {
  constructor({statements}) {
    if (statements === undefined || !Array.isArray(statements) || statements.some(f => isNotStatement(f))) {
      throw new TypeError('Field "statements" of Block constructor is of incorrect type (expected [Statement])');
    }
    this.type = 'Block';
    this.statements = statements;
  }
}

export class BlockStatement {
  constructor({block}) {
    if (block === undefined || block.type !== 'Block') {
      throw new TypeError('Field "block" of BlockStatement constructor is of incorrect type (expected Block)');
    }
    this.type = 'BlockStatement';
    this.block = block;
  }
}

export class BreakStatement {
  constructor({label}) {
    if (label === undefined || label !== null && (typeof label !== 'string')) {
      throw new TypeError('Field "label" of BreakStatement constructor is of incorrect type (expected null or string)');
    }
    this.type = 'BreakStatement';
    this.label = label;
  }
}

export class CallExpression {
  constructor({callee, arguments: _arguments}) {
    if (callee === undefined || (isNotExpression(callee)) && (callee.type !== 'Super')) {
      throw new TypeError('Field "callee" of CallExpression constructor is of incorrect type (expected one of {Expression, Super})');
    }
    if (_arguments === undefined || !Array.isArray(_arguments) || _arguments.some(f => f === undefined || (isNotExpression(f)) && (f.type !== 'SpreadElement'))) {
      throw new TypeError('Field "arguments" of CallExpression constructor is of incorrect type (expected [one of {Expression, SpreadElement}])');
    }
    this.type = 'CallExpression';
    this.callee = callee;
    this.arguments = _arguments;
  }
}

export class CatchClause {
  constructor({binding, body}) {
    if (binding === undefined || (binding.type !== 'BindingIdentifier') && ((binding.type !== 'ArrayBinding') && (binding.type !== 'ObjectBinding'))) {
      throw new TypeError('Field "binding" of CatchClause constructor is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding})');
    }
    if (body === undefined || body.type !== 'Block') {
      throw new TypeError('Field "body" of CatchClause constructor is of incorrect type (expected Block)');
    }
    this.type = 'CatchClause';
    this.binding = binding;
    this.body = body;
  }
}

export class ClassDeclaration {
  constructor({name, super: _super, elements}) {
    if (name === undefined || name.type !== 'BindingIdentifier') {
      throw new TypeError('Field "name" of ClassDeclaration constructor is of incorrect type (expected BindingIdentifier)');
    }
    if (_super === undefined || _super !== null && (isNotExpression(_super))) {
      throw new TypeError('Field "super" of ClassDeclaration constructor is of incorrect type (expected null or Expression)');
    }
    if (elements === undefined || !Array.isArray(elements) || elements.some(f => f === undefined || f.type !== 'ClassElement')) {
      throw new TypeError('Field "elements" of ClassDeclaration constructor is of incorrect type (expected [ClassElement])');
    }
    this.type = 'ClassDeclaration';
    this.name = name;
    this.super = _super;
    this.elements = elements;
  }
}

export class ClassElement {
  constructor({isStatic, method}) {
    if (isStatic === undefined || typeof isStatic !== 'boolean') {
      throw new TypeError('Field "isStatic" of ClassElement constructor is of incorrect type (expected boolean)');
    }
    if (method === undefined || (method.type !== 'Getter') && (method.type !== 'Method') && (method.type !== 'Setter')) {
      throw new TypeError('Field "method" of ClassElement constructor is of incorrect type (expected one of {Getter, Method, Setter})');
    }
    this.type = 'ClassElement';
    this.isStatic = isStatic;
    this.method = method;
  }
}

export class ClassExpression {
  constructor({name, super: _super, elements}) {
    if (name === undefined || name !== null && (name.type !== 'BindingIdentifier')) {
      throw new TypeError('Field "name" of ClassExpression constructor is of incorrect type (expected null or BindingIdentifier)');
    }
    if (_super === undefined || _super !== null && (isNotExpression(_super))) {
      throw new TypeError('Field "super" of ClassExpression constructor is of incorrect type (expected null or Expression)');
    }
    if (elements === undefined || !Array.isArray(elements) || elements.some(f => f === undefined || f.type !== 'ClassElement')) {
      throw new TypeError('Field "elements" of ClassExpression constructor is of incorrect type (expected [ClassElement])');
    }
    this.type = 'ClassExpression';
    this.name = name;
    this.super = _super;
    this.elements = elements;
  }
}

export class CompoundAssignmentExpression {
  constructor({binding, operator, expression}) {
    if (binding === undefined || (binding.type !== 'AssignmentTargetIdentifier') && ((binding.type !== 'ComputedMemberAssignmentTarget') && (binding.type !== 'StaticMemberAssignmentTarget'))) {
      throw new TypeError('Field "binding" of CompoundAssignmentExpression constructor is of incorrect type (expected one of {AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget})');
    }
    if (operator === undefined || ["+=","-=","*=","/=","%=","**=","<<=",">>=",">>>=","|=","^=","&="].indexOf(operator) === -1) {
      throw new TypeError('Field "operator" of CompoundAssignmentExpression constructor is of incorrect type (expected one of {"+=", "-=", "*=", "/=", "%=", "**=", "<<=", ">>=", ">>>=", "|=", "^=", "&="})');
    }
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of CompoundAssignmentExpression constructor is of incorrect type (expected Expression)');
    }
    this.type = 'CompoundAssignmentExpression';
    this.binding = binding;
    this.operator = operator;
    this.expression = expression;
  }
}

export class ComputedMemberAssignmentTarget {
  constructor({object, expression}) {
    if (object === undefined || (isNotExpression(object)) && (object.type !== 'Super')) {
      throw new TypeError('Field "object" of ComputedMemberAssignmentTarget constructor is of incorrect type (expected one of {Expression, Super})');
    }
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of ComputedMemberAssignmentTarget constructor is of incorrect type (expected Expression)');
    }
    this.type = 'ComputedMemberAssignmentTarget';
    this.object = object;
    this.expression = expression;
  }
}

export class ComputedMemberExpression {
  constructor({object, expression}) {
    if (object === undefined || (isNotExpression(object)) && (object.type !== 'Super')) {
      throw new TypeError('Field "object" of ComputedMemberExpression constructor is of incorrect type (expected one of {Expression, Super})');
    }
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of ComputedMemberExpression constructor is of incorrect type (expected Expression)');
    }
    this.type = 'ComputedMemberExpression';
    this.object = object;
    this.expression = expression;
  }
}

export class ComputedPropertyName {
  constructor({expression}) {
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of ComputedPropertyName constructor is of incorrect type (expected Expression)');
    }
    this.type = 'ComputedPropertyName';
    this.expression = expression;
  }
}

export class ConditionalExpression {
  constructor({test, consequent, alternate}) {
    if (isNotExpression(test)) {
      throw new TypeError('Field "test" of ConditionalExpression constructor is of incorrect type (expected Expression)');
    }
    if (isNotExpression(consequent)) {
      throw new TypeError('Field "consequent" of ConditionalExpression constructor is of incorrect type (expected Expression)');
    }
    if (isNotExpression(alternate)) {
      throw new TypeError('Field "alternate" of ConditionalExpression constructor is of incorrect type (expected Expression)');
    }
    this.type = 'ConditionalExpression';
    this.test = test;
    this.consequent = consequent;
    this.alternate = alternate;
  }
}

export class ContinueStatement {
  constructor({label}) {
    if (label === undefined || label !== null && (typeof label !== 'string')) {
      throw new TypeError('Field "label" of ContinueStatement constructor is of incorrect type (expected null or string)');
    }
    this.type = 'ContinueStatement';
    this.label = label;
  }
}

export class DataProperty {
  constructor({name, expression}) {
    if (name === undefined || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {
      throw new TypeError('Field "name" of DataProperty constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName})');
    }
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of DataProperty constructor is of incorrect type (expected Expression)');
    }
    this.type = 'DataProperty';
    this.name = name;
    this.expression = expression;
  }
}

export class DebuggerStatement {
  constructor() {
    this.type = 'DebuggerStatement';
  }
}

export class Directive {
  constructor({rawValue}) {
    if (rawValue === undefined || typeof rawValue !== 'string') {
      throw new TypeError('Field "rawValue" of Directive constructor is of incorrect type (expected string)');
    }
    this.type = 'Directive';
    this.rawValue = rawValue;
  }
}

export class DoWhileStatement {
  constructor({body, test}) {
    if (isNotStatement(body)) {
      throw new TypeError('Field "body" of DoWhileStatement constructor is of incorrect type (expected Statement)');
    }
    if (isNotExpression(test)) {
      throw new TypeError('Field "test" of DoWhileStatement constructor is of incorrect type (expected Expression)');
    }
    this.type = 'DoWhileStatement';
    this.body = body;
    this.test = test;
  }
}

export class EmptyStatement {
  constructor() {
    this.type = 'EmptyStatement';
  }
}

export class Export {
  constructor({declaration}) {
    if (declaration === undefined || (declaration.type !== 'ClassDeclaration') && (declaration.type !== 'FunctionDeclaration') && (declaration.type !== 'VariableDeclaration')) {
      throw new TypeError('Field "declaration" of Export constructor is of incorrect type (expected one of {ClassDeclaration, FunctionDeclaration, VariableDeclaration})');
    }
    this.type = 'Export';
    this.declaration = declaration;
  }
}

export class ExportAllFrom {
  constructor({moduleSpecifier}) {
    if (moduleSpecifier === undefined || typeof moduleSpecifier !== 'string') {
      throw new TypeError('Field "moduleSpecifier" of ExportAllFrom constructor is of incorrect type (expected string)');
    }
    this.type = 'ExportAllFrom';
    this.moduleSpecifier = moduleSpecifier;
  }
}

export class ExportDefault {
  constructor({body}) {
    if (body === undefined || (body.type !== 'ClassDeclaration') && (isNotExpression(body)) && (body.type !== 'FunctionDeclaration')) {
      throw new TypeError('Field "body" of ExportDefault constructor is of incorrect type (expected one of {ClassDeclaration, Expression, FunctionDeclaration})');
    }
    this.type = 'ExportDefault';
    this.body = body;
  }
}

export class ExportFrom {
  constructor({namedExports, moduleSpecifier}) {
    if (namedExports === undefined || !Array.isArray(namedExports) || namedExports.some(f => f === undefined || f.type !== 'ExportFromSpecifier')) {
      throw new TypeError('Field "namedExports" of ExportFrom constructor is of incorrect type (expected [ExportFromSpecifier])');
    }
    if (moduleSpecifier === undefined || typeof moduleSpecifier !== 'string') {
      throw new TypeError('Field "moduleSpecifier" of ExportFrom constructor is of incorrect type (expected string)');
    }
    this.type = 'ExportFrom';
    this.namedExports = namedExports;
    this.moduleSpecifier = moduleSpecifier;
  }
}

export class ExportFromSpecifier {
  constructor({name, exportedName}) {
    if (name === undefined || typeof name !== 'string') {
      throw new TypeError('Field "name" of ExportFromSpecifier constructor is of incorrect type (expected string)');
    }
    if (exportedName === undefined || exportedName !== null && (typeof exportedName !== 'string')) {
      throw new TypeError('Field "exportedName" of ExportFromSpecifier constructor is of incorrect type (expected null or string)');
    }
    this.type = 'ExportFromSpecifier';
    this.name = name;
    this.exportedName = exportedName;
  }
}

export class ExportLocalSpecifier {
  constructor({name, exportedName}) {
    if (name === undefined || name.type !== 'IdentifierExpression') {
      throw new TypeError('Field "name" of ExportLocalSpecifier constructor is of incorrect type (expected IdentifierExpression)');
    }
    if (exportedName === undefined || exportedName !== null && (typeof exportedName !== 'string')) {
      throw new TypeError('Field "exportedName" of ExportLocalSpecifier constructor is of incorrect type (expected null or string)');
    }
    this.type = 'ExportLocalSpecifier';
    this.name = name;
    this.exportedName = exportedName;
  }
}

export class ExportLocals {
  constructor({namedExports}) {
    if (namedExports === undefined || !Array.isArray(namedExports) || namedExports.some(f => f === undefined || f.type !== 'ExportLocalSpecifier')) {
      throw new TypeError('Field "namedExports" of ExportLocals constructor is of incorrect type (expected [ExportLocalSpecifier])');
    }
    this.type = 'ExportLocals';
    this.namedExports = namedExports;
  }
}

export class ExpressionStatement {
  constructor({expression}) {
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of ExpressionStatement constructor is of incorrect type (expected Expression)');
    }
    this.type = 'ExpressionStatement';
    this.expression = expression;
  }
}

export class ForInStatement {
  constructor({left, right, body}) {
    if (left === undefined || (((left.type !== 'ArrayAssignmentTarget') && (left.type !== 'ObjectAssignmentTarget')) && ((left.type !== 'AssignmentTargetIdentifier') && ((left.type !== 'ComputedMemberAssignmentTarget') && (left.type !== 'StaticMemberAssignmentTarget')))) && (left.type !== 'VariableDeclaration')) {
      throw new TypeError('Field "left" of ForInStatement constructor is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration})');
    }
    if (isNotExpression(right)) {
      throw new TypeError('Field "right" of ForInStatement constructor is of incorrect type (expected Expression)');
    }
    if (isNotStatement(body)) {
      throw new TypeError('Field "body" of ForInStatement constructor is of incorrect type (expected Statement)');
    }
    this.type = 'ForInStatement';
    this.left = left;
    this.right = right;
    this.body = body;
  }
}

export class ForOfStatement {
  constructor({left, right, body}) {
    if (left === undefined || (((left.type !== 'ArrayAssignmentTarget') && (left.type !== 'ObjectAssignmentTarget')) && ((left.type !== 'AssignmentTargetIdentifier') && ((left.type !== 'ComputedMemberAssignmentTarget') && (left.type !== 'StaticMemberAssignmentTarget')))) && (left.type !== 'VariableDeclaration')) {
      throw new TypeError('Field "left" of ForOfStatement constructor is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration})');
    }
    if (isNotExpression(right)) {
      throw new TypeError('Field "right" of ForOfStatement constructor is of incorrect type (expected Expression)');
    }
    if (isNotStatement(body)) {
      throw new TypeError('Field "body" of ForOfStatement constructor is of incorrect type (expected Statement)');
    }
    this.type = 'ForOfStatement';
    this.left = left;
    this.right = right;
    this.body = body;
  }
}

export class ForStatement {
  constructor({init, test, update, body}) {
    if (init === undefined || init !== null && ((isNotExpression(init)) && (init.type !== 'VariableDeclaration'))) {
      throw new TypeError('Field "init" of ForStatement constructor is of incorrect type (expected null or one of {Expression, VariableDeclaration})');
    }
    if (test === undefined || test !== null && (isNotExpression(test))) {
      throw new TypeError('Field "test" of ForStatement constructor is of incorrect type (expected null or Expression)');
    }
    if (update === undefined || update !== null && (isNotExpression(update))) {
      throw new TypeError('Field "update" of ForStatement constructor is of incorrect type (expected null or Expression)');
    }
    if (isNotStatement(body)) {
      throw new TypeError('Field "body" of ForStatement constructor is of incorrect type (expected Statement)');
    }
    this.type = 'ForStatement';
    this.init = init;
    this.test = test;
    this.update = update;
    this.body = body;
  }
}

export class FormalParameters {
  constructor({items, rest}) {
    if (items === undefined || !Array.isArray(items) || items.some(f => f === undefined || (f.type !== 'BindingWithDefault') && ((f.type !== 'BindingIdentifier') && ((f.type !== 'ArrayBinding') && (f.type !== 'ObjectBinding'))))) {
      throw new TypeError('Field "items" of FormalParameters constructor is of incorrect type (expected [one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}])');
    }
    if (rest === undefined || rest !== null && ((rest.type !== 'BindingIdentifier') && ((rest.type !== 'ArrayBinding') && (rest.type !== 'ObjectBinding')))) {
      throw new TypeError('Field "rest" of FormalParameters constructor is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding})');
    }
    this.type = 'FormalParameters';
    this.items = items;
    this.rest = rest;
  }
}

export class FunctionBody {
  constructor({directives, statements}) {
    if (directives === undefined || !Array.isArray(directives) || directives.some(f => f === undefined || f.type !== 'Directive')) {
      throw new TypeError('Field "directives" of FunctionBody constructor is of incorrect type (expected [Directive])');
    }
    if (statements === undefined || !Array.isArray(statements) || statements.some(f => isNotStatement(f))) {
      throw new TypeError('Field "statements" of FunctionBody constructor is of incorrect type (expected [Statement])');
    }
    this.type = 'FunctionBody';
    this.directives = directives;
    this.statements = statements;
  }
}

export class FunctionDeclaration {
  constructor({isGenerator, name, params, body}) {
    if (isGenerator === undefined || typeof isGenerator !== 'boolean') {
      throw new TypeError('Field "isGenerator" of FunctionDeclaration constructor is of incorrect type (expected boolean)');
    }
    if (name === undefined || name.type !== 'BindingIdentifier') {
      throw new TypeError('Field "name" of FunctionDeclaration constructor is of incorrect type (expected BindingIdentifier)');
    }
    if (params === undefined || params.type !== 'FormalParameters') {
      throw new TypeError('Field "params" of FunctionDeclaration constructor is of incorrect type (expected FormalParameters)');
    }
    if (body === undefined || body.type !== 'FunctionBody') {
      throw new TypeError('Field "body" of FunctionDeclaration constructor is of incorrect type (expected FunctionBody)');
    }
    this.type = 'FunctionDeclaration';
    this.isGenerator = isGenerator;
    this.name = name;
    this.params = params;
    this.body = body;
  }
}

export class FunctionExpression {
  constructor({isGenerator, name, params, body}) {
    if (isGenerator === undefined || typeof isGenerator !== 'boolean') {
      throw new TypeError('Field "isGenerator" of FunctionExpression constructor is of incorrect type (expected boolean)');
    }
    if (name === undefined || name !== null && (name.type !== 'BindingIdentifier')) {
      throw new TypeError('Field "name" of FunctionExpression constructor is of incorrect type (expected null or BindingIdentifier)');
    }
    if (params === undefined || params.type !== 'FormalParameters') {
      throw new TypeError('Field "params" of FunctionExpression constructor is of incorrect type (expected FormalParameters)');
    }
    if (body === undefined || body.type !== 'FunctionBody') {
      throw new TypeError('Field "body" of FunctionExpression constructor is of incorrect type (expected FunctionBody)');
    }
    this.type = 'FunctionExpression';
    this.isGenerator = isGenerator;
    this.name = name;
    this.params = params;
    this.body = body;
  }
}

export class Getter {
  constructor({name, body}) {
    if (name === undefined || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {
      throw new TypeError('Field "name" of Getter constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName})');
    }
    if (body === undefined || body.type !== 'FunctionBody') {
      throw new TypeError('Field "body" of Getter constructor is of incorrect type (expected FunctionBody)');
    }
    this.type = 'Getter';
    this.name = name;
    this.body = body;
  }
}

export class IdentifierExpression {
  constructor({name}) {
    if (name === undefined || typeof name !== 'string') {
      throw new TypeError('Field "name" of IdentifierExpression constructor is of incorrect type (expected string)');
    }
    this.type = 'IdentifierExpression';
    this.name = name;
  }
}

export class IfStatement {
  constructor({test, consequent, alternate}) {
    if (isNotExpression(test)) {
      throw new TypeError('Field "test" of IfStatement constructor is of incorrect type (expected Expression)');
    }
    if (isNotStatement(consequent)) {
      throw new TypeError('Field "consequent" of IfStatement constructor is of incorrect type (expected Statement)');
    }
    if (alternate === undefined || alternate !== null && (isNotStatement(alternate))) {
      throw new TypeError('Field "alternate" of IfStatement constructor is of incorrect type (expected null or Statement)');
    }
    this.type = 'IfStatement';
    this.test = test;
    this.consequent = consequent;
    this.alternate = alternate;
  }
}

export class Import {
  constructor({defaultBinding, namedImports, moduleSpecifier}) {
    if (defaultBinding === undefined || defaultBinding !== null && (defaultBinding.type !== 'BindingIdentifier')) {
      throw new TypeError('Field "defaultBinding" of Import constructor is of incorrect type (expected null or BindingIdentifier)');
    }
    if (namedImports === undefined || !Array.isArray(namedImports) || namedImports.some(f => f === undefined || f.type !== 'ImportSpecifier')) {
      throw new TypeError('Field "namedImports" of Import constructor is of incorrect type (expected [ImportSpecifier])');
    }
    if (moduleSpecifier === undefined || typeof moduleSpecifier !== 'string') {
      throw new TypeError('Field "moduleSpecifier" of Import constructor is of incorrect type (expected string)');
    }
    this.type = 'Import';
    this.defaultBinding = defaultBinding;
    this.namedImports = namedImports;
    this.moduleSpecifier = moduleSpecifier;
  }
}

export class ImportNamespace {
  constructor({defaultBinding, namespaceBinding, moduleSpecifier}) {
    if (defaultBinding === undefined || defaultBinding !== null && (defaultBinding.type !== 'BindingIdentifier')) {
      throw new TypeError('Field "defaultBinding" of ImportNamespace constructor is of incorrect type (expected null or BindingIdentifier)');
    }
    if (namespaceBinding === undefined || namespaceBinding.type !== 'BindingIdentifier') {
      throw new TypeError('Field "namespaceBinding" of ImportNamespace constructor is of incorrect type (expected BindingIdentifier)');
    }
    if (moduleSpecifier === undefined || typeof moduleSpecifier !== 'string') {
      throw new TypeError('Field "moduleSpecifier" of ImportNamespace constructor is of incorrect type (expected string)');
    }
    this.type = 'ImportNamespace';
    this.defaultBinding = defaultBinding;
    this.namespaceBinding = namespaceBinding;
    this.moduleSpecifier = moduleSpecifier;
  }
}

export class ImportSpecifier {
  constructor({name, binding}) {
    if (name === undefined || name !== null && (typeof name !== 'string')) {
      throw new TypeError('Field "name" of ImportSpecifier constructor is of incorrect type (expected null or string)');
    }
    if (binding === undefined || binding.type !== 'BindingIdentifier') {
      throw new TypeError('Field "binding" of ImportSpecifier constructor is of incorrect type (expected BindingIdentifier)');
    }
    this.type = 'ImportSpecifier';
    this.name = name;
    this.binding = binding;
  }
}

export class LabeledStatement {
  constructor({label, body}) {
    if (label === undefined || typeof label !== 'string') {
      throw new TypeError('Field "label" of LabeledStatement constructor is of incorrect type (expected string)');
    }
    if (isNotStatement(body)) {
      throw new TypeError('Field "body" of LabeledStatement constructor is of incorrect type (expected Statement)');
    }
    this.type = 'LabeledStatement';
    this.label = label;
    this.body = body;
  }
}

export class LiteralBooleanExpression {
  constructor({value}) {
    if (value === undefined || typeof value !== 'boolean') {
      throw new TypeError('Field "value" of LiteralBooleanExpression constructor is of incorrect type (expected boolean)');
    }
    this.type = 'LiteralBooleanExpression';
    this.value = value;
  }
}

export class LiteralInfinityExpression {
  constructor() {
    this.type = 'LiteralInfinityExpression';
  }
}

export class LiteralNullExpression {
  constructor() {
    this.type = 'LiteralNullExpression';
  }
}

export class LiteralNumericExpression {
  constructor({value}) {
    if (value === undefined || typeof value !== 'number') {
      throw new TypeError('Field "value" of LiteralNumericExpression constructor is of incorrect type (expected number)');
    }
    this.type = 'LiteralNumericExpression';
    this.value = value;
  }
}

export class LiteralRegExpExpression {
  constructor({pattern, global, ignoreCase, multiLine, sticky, unicode}) {
    if (pattern === undefined || typeof pattern !== 'string') {
      throw new TypeError('Field "pattern" of LiteralRegExpExpression constructor is of incorrect type (expected string)');
    }
    if (global === undefined || typeof global !== 'boolean') {
      throw new TypeError('Field "global" of LiteralRegExpExpression constructor is of incorrect type (expected boolean)');
    }
    if (ignoreCase === undefined || typeof ignoreCase !== 'boolean') {
      throw new TypeError('Field "ignoreCase" of LiteralRegExpExpression constructor is of incorrect type (expected boolean)');
    }
    if (multiLine === undefined || typeof multiLine !== 'boolean') {
      throw new TypeError('Field "multiLine" of LiteralRegExpExpression constructor is of incorrect type (expected boolean)');
    }
    if (sticky === undefined || typeof sticky !== 'boolean') {
      throw new TypeError('Field "sticky" of LiteralRegExpExpression constructor is of incorrect type (expected boolean)');
    }
    if (unicode === undefined || typeof unicode !== 'boolean') {
      throw new TypeError('Field "unicode" of LiteralRegExpExpression constructor is of incorrect type (expected boolean)');
    }
    this.type = 'LiteralRegExpExpression';
    this.pattern = pattern;
    this.global = global;
    this.ignoreCase = ignoreCase;
    this.multiLine = multiLine;
    this.sticky = sticky;
    this.unicode = unicode;
  }
}

export class LiteralStringExpression {
  constructor({value}) {
    if (value === undefined || typeof value !== 'string') {
      throw new TypeError('Field "value" of LiteralStringExpression constructor is of incorrect type (expected string)');
    }
    this.type = 'LiteralStringExpression';
    this.value = value;
  }
}

export class Method {
  constructor({isGenerator, name, params, body}) {
    if (isGenerator === undefined || typeof isGenerator !== 'boolean') {
      throw new TypeError('Field "isGenerator" of Method constructor is of incorrect type (expected boolean)');
    }
    if (name === undefined || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {
      throw new TypeError('Field "name" of Method constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName})');
    }
    if (params === undefined || params.type !== 'FormalParameters') {
      throw new TypeError('Field "params" of Method constructor is of incorrect type (expected FormalParameters)');
    }
    if (body === undefined || body.type !== 'FunctionBody') {
      throw new TypeError('Field "body" of Method constructor is of incorrect type (expected FunctionBody)');
    }
    this.type = 'Method';
    this.isGenerator = isGenerator;
    this.name = name;
    this.params = params;
    this.body = body;
  }
}

export class Module {
  constructor({directives, items}) {
    if (directives === undefined || !Array.isArray(directives) || directives.some(f => f === undefined || f.type !== 'Directive')) {
      throw new TypeError('Field "directives" of Module constructor is of incorrect type (expected [Directive])');
    }
    if (items === undefined || !Array.isArray(items) || items.some(f => f === undefined || ((f.type !== 'Export') && (f.type !== 'ExportAllFrom') && (f.type !== 'ExportDefault') && (f.type !== 'ExportFrom') && (f.type !== 'ExportLocals')) && ((f.type !== 'Import') && (f.type !== 'ImportNamespace')) && (isNotStatement(f)))) {
      throw new TypeError('Field "items" of Module constructor is of incorrect type (expected [one of {Export, ExportAllFrom, ExportDefault, ExportFrom, ExportLocals, Import, ImportNamespace, Statement}])');
    }
    this.type = 'Module';
    this.directives = directives;
    this.items = items;
  }
}

export class NewExpression {
  constructor({callee, arguments: _arguments}) {
    if (isNotExpression(callee)) {
      throw new TypeError('Field "callee" of NewExpression constructor is of incorrect type (expected Expression)');
    }
    if (_arguments === undefined || !Array.isArray(_arguments) || _arguments.some(f => f === undefined || (isNotExpression(f)) && (f.type !== 'SpreadElement'))) {
      throw new TypeError('Field "arguments" of NewExpression constructor is of incorrect type (expected [one of {Expression, SpreadElement}])');
    }
    this.type = 'NewExpression';
    this.callee = callee;
    this.arguments = _arguments;
  }
}

export class NewTargetExpression {
  constructor() {
    this.type = 'NewTargetExpression';
  }
}

export class ObjectAssignmentTarget {
  constructor({properties}) {
    if (properties === undefined || !Array.isArray(properties) || properties.some(f => f === undefined || (f.type !== 'AssignmentTargetPropertyIdentifier') && (f.type !== 'AssignmentTargetPropertyProperty'))) {
      throw new TypeError('Field "properties" of ObjectAssignmentTarget constructor is of incorrect type (expected [one of {AssignmentTargetPropertyIdentifier, AssignmentTargetPropertyProperty}])');
    }
    this.type = 'ObjectAssignmentTarget';
    this.properties = properties;
  }
}

export class ObjectBinding {
  constructor({properties}) {
    if (properties === undefined || !Array.isArray(properties) || properties.some(f => f === undefined || (f.type !== 'BindingPropertyIdentifier') && (f.type !== 'BindingPropertyProperty'))) {
      throw new TypeError('Field "properties" of ObjectBinding constructor is of incorrect type (expected [one of {BindingPropertyIdentifier, BindingPropertyProperty}])');
    }
    this.type = 'ObjectBinding';
    this.properties = properties;
  }
}

export class ObjectExpression {
  constructor({properties}) {
    if (properties === undefined || !Array.isArray(properties) || properties.some(f => f === undefined || ((f.type !== 'DataProperty') && ((f.type !== 'Getter') && (f.type !== 'Method') && (f.type !== 'Setter'))) && (f.type !== 'ShorthandProperty'))) {
      throw new TypeError('Field "properties" of ObjectExpression constructor is of incorrect type (expected [one of {DataProperty, Getter, Method, Setter, ShorthandProperty}])');
    }
    this.type = 'ObjectExpression';
    this.properties = properties;
  }
}

export class ReturnStatement {
  constructor({expression}) {
    if (expression === undefined || expression !== null && (isNotExpression(expression))) {
      throw new TypeError('Field "expression" of ReturnStatement constructor is of incorrect type (expected null or Expression)');
    }
    this.type = 'ReturnStatement';
    this.expression = expression;
  }
}

export class Script {
  constructor({directives, statements}) {
    if (directives === undefined || !Array.isArray(directives) || directives.some(f => f === undefined || f.type !== 'Directive')) {
      throw new TypeError('Field "directives" of Script constructor is of incorrect type (expected [Directive])');
    }
    if (statements === undefined || !Array.isArray(statements) || statements.some(f => isNotStatement(f))) {
      throw new TypeError('Field "statements" of Script constructor is of incorrect type (expected [Statement])');
    }
    this.type = 'Script';
    this.directives = directives;
    this.statements = statements;
  }
}

export class Setter {
  constructor({name, param, body}) {
    if (name === undefined || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {
      throw new TypeError('Field "name" of Setter constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName})');
    }
    if (param === undefined || (param.type !== 'BindingWithDefault') && ((param.type !== 'BindingIdentifier') && ((param.type !== 'ArrayBinding') && (param.type !== 'ObjectBinding')))) {
      throw new TypeError('Field "param" of Setter constructor is of incorrect type (expected one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding})');
    }
    if (body === undefined || body.type !== 'FunctionBody') {
      throw new TypeError('Field "body" of Setter constructor is of incorrect type (expected FunctionBody)');
    }
    this.type = 'Setter';
    this.name = name;
    this.param = param;
    this.body = body;
  }
}

export class ShorthandProperty {
  constructor({name}) {
    if (name === undefined || name.type !== 'IdentifierExpression') {
      throw new TypeError('Field "name" of ShorthandProperty constructor is of incorrect type (expected IdentifierExpression)');
    }
    this.type = 'ShorthandProperty';
    this.name = name;
  }
}

export class SpreadElement {
  constructor({expression}) {
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of SpreadElement constructor is of incorrect type (expected Expression)');
    }
    this.type = 'SpreadElement';
    this.expression = expression;
  }
}

export class StaticMemberAssignmentTarget {
  constructor({object, property}) {
    if (object === undefined || (isNotExpression(object)) && (object.type !== 'Super')) {
      throw new TypeError('Field "object" of StaticMemberAssignmentTarget constructor is of incorrect type (expected one of {Expression, Super})');
    }
    if (property === undefined || typeof property !== 'string') {
      throw new TypeError('Field "property" of StaticMemberAssignmentTarget constructor is of incorrect type (expected string)');
    }
    this.type = 'StaticMemberAssignmentTarget';
    this.object = object;
    this.property = property;
  }
}

export class StaticMemberExpression {
  constructor({object, property}) {
    if (object === undefined || (isNotExpression(object)) && (object.type !== 'Super')) {
      throw new TypeError('Field "object" of StaticMemberExpression constructor is of incorrect type (expected one of {Expression, Super})');
    }
    if (property === undefined || typeof property !== 'string') {
      throw new TypeError('Field "property" of StaticMemberExpression constructor is of incorrect type (expected string)');
    }
    this.type = 'StaticMemberExpression';
    this.object = object;
    this.property = property;
  }
}

export class StaticPropertyName {
  constructor({value}) {
    if (value === undefined || typeof value !== 'string') {
      throw new TypeError('Field "value" of StaticPropertyName constructor is of incorrect type (expected string)');
    }
    this.type = 'StaticPropertyName';
    this.value = value;
  }
}

export class Super {
  constructor() {
    this.type = 'Super';
  }
}

export class SwitchCase {
  constructor({test, consequent}) {
    if (isNotExpression(test)) {
      throw new TypeError('Field "test" of SwitchCase constructor is of incorrect type (expected Expression)');
    }
    if (consequent === undefined || !Array.isArray(consequent) || consequent.some(f => isNotStatement(f))) {
      throw new TypeError('Field "consequent" of SwitchCase constructor is of incorrect type (expected [Statement])');
    }
    this.type = 'SwitchCase';
    this.test = test;
    this.consequent = consequent;
  }
}

export class SwitchDefault {
  constructor({consequent}) {
    if (consequent === undefined || !Array.isArray(consequent) || consequent.some(f => isNotStatement(f))) {
      throw new TypeError('Field "consequent" of SwitchDefault constructor is of incorrect type (expected [Statement])');
    }
    this.type = 'SwitchDefault';
    this.consequent = consequent;
  }
}

export class SwitchStatement {
  constructor({discriminant, cases}) {
    if (isNotExpression(discriminant)) {
      throw new TypeError('Field "discriminant" of SwitchStatement constructor is of incorrect type (expected Expression)');
    }
    if (cases === undefined || !Array.isArray(cases) || cases.some(f => f === undefined || f.type !== 'SwitchCase')) {
      throw new TypeError('Field "cases" of SwitchStatement constructor is of incorrect type (expected [SwitchCase])');
    }
    this.type = 'SwitchStatement';
    this.discriminant = discriminant;
    this.cases = cases;
  }
}

export class SwitchStatementWithDefault {
  constructor({discriminant, preDefaultCases, defaultCase, postDefaultCases}) {
    if (isNotExpression(discriminant)) {
      throw new TypeError('Field "discriminant" of SwitchStatementWithDefault constructor is of incorrect type (expected Expression)');
    }
    if (preDefaultCases === undefined || !Array.isArray(preDefaultCases) || preDefaultCases.some(f => f === undefined || f.type !== 'SwitchCase')) {
      throw new TypeError('Field "preDefaultCases" of SwitchStatementWithDefault constructor is of incorrect type (expected [SwitchCase])');
    }
    if (defaultCase === undefined || defaultCase.type !== 'SwitchDefault') {
      throw new TypeError('Field "defaultCase" of SwitchStatementWithDefault constructor is of incorrect type (expected SwitchDefault)');
    }
    if (postDefaultCases === undefined || !Array.isArray(postDefaultCases) || postDefaultCases.some(f => f === undefined || f.type !== 'SwitchCase')) {
      throw new TypeError('Field "postDefaultCases" of SwitchStatementWithDefault constructor is of incorrect type (expected [SwitchCase])');
    }
    this.type = 'SwitchStatementWithDefault';
    this.discriminant = discriminant;
    this.preDefaultCases = preDefaultCases;
    this.defaultCase = defaultCase;
    this.postDefaultCases = postDefaultCases;
  }
}

export class TemplateElement {
  constructor({rawValue}) {
    if (rawValue === undefined || typeof rawValue !== 'string') {
      throw new TypeError('Field "rawValue" of TemplateElement constructor is of incorrect type (expected string)');
    }
    this.type = 'TemplateElement';
    this.rawValue = rawValue;
  }
}

export class TemplateExpression {
  constructor({tag, elements}) {
    if (tag === undefined || tag !== null && (isNotExpression(tag))) {
      throw new TypeError('Field "tag" of TemplateExpression constructor is of incorrect type (expected null or Expression)');
    }
    if (elements === undefined || !Array.isArray(elements) || elements.some(f => f === undefined || (isNotExpression(f)) && (f.type !== 'TemplateElement'))) {
      throw new TypeError('Field "elements" of TemplateExpression constructor is of incorrect type (expected [one of {Expression, TemplateElement}])');
    }
    this.type = 'TemplateExpression';
    this.tag = tag;
    this.elements = elements;
  }
}

export class ThisExpression {
  constructor() {
    this.type = 'ThisExpression';
  }
}

export class ThrowStatement {
  constructor({expression}) {
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of ThrowStatement constructor is of incorrect type (expected Expression)');
    }
    this.type = 'ThrowStatement';
    this.expression = expression;
  }
}

export class TryCatchStatement {
  constructor({body, catchClause}) {
    if (body === undefined || body.type !== 'Block') {
      throw new TypeError('Field "body" of TryCatchStatement constructor is of incorrect type (expected Block)');
    }
    if (catchClause === undefined || catchClause.type !== 'CatchClause') {
      throw new TypeError('Field "catchClause" of TryCatchStatement constructor is of incorrect type (expected CatchClause)');
    }
    this.type = 'TryCatchStatement';
    this.body = body;
    this.catchClause = catchClause;
  }
}

export class TryFinallyStatement {
  constructor({body, catchClause, finalizer}) {
    if (body === undefined || body.type !== 'Block') {
      throw new TypeError('Field "body" of TryFinallyStatement constructor is of incorrect type (expected Block)');
    }
    if (catchClause === undefined || catchClause !== null && (catchClause.type !== 'CatchClause')) {
      throw new TypeError('Field "catchClause" of TryFinallyStatement constructor is of incorrect type (expected null or CatchClause)');
    }
    if (finalizer === undefined || finalizer.type !== 'Block') {
      throw new TypeError('Field "finalizer" of TryFinallyStatement constructor is of incorrect type (expected Block)');
    }
    this.type = 'TryFinallyStatement';
    this.body = body;
    this.catchClause = catchClause;
    this.finalizer = finalizer;
  }
}

export class UnaryExpression {
  constructor({operator, operand}) {
    if (operator === undefined || ["+","-","!","~","typeof","void","delete"].indexOf(operator) === -1) {
      throw new TypeError('Field "operator" of UnaryExpression constructor is of incorrect type (expected one of {"+", "-", "!", "~", "typeof", "void", "delete"})');
    }
    if (isNotExpression(operand)) {
      throw new TypeError('Field "operand" of UnaryExpression constructor is of incorrect type (expected Expression)');
    }
    this.type = 'UnaryExpression';
    this.operator = operator;
    this.operand = operand;
  }
}

export class UpdateExpression {
  constructor({isPrefix, operator, operand}) {
    if (isPrefix === undefined || typeof isPrefix !== 'boolean') {
      throw new TypeError('Field "isPrefix" of UpdateExpression constructor is of incorrect type (expected boolean)');
    }
    if (operator === undefined || ["++","--"].indexOf(operator) === -1) {
      throw new TypeError('Field "operator" of UpdateExpression constructor is of incorrect type (expected one of {"++", "--"})');
    }
    if (operand === undefined || (operand.type !== 'AssignmentTargetIdentifier') && ((operand.type !== 'ComputedMemberAssignmentTarget') && (operand.type !== 'StaticMemberAssignmentTarget'))) {
      throw new TypeError('Field "operand" of UpdateExpression constructor is of incorrect type (expected one of {AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget})');
    }
    this.type = 'UpdateExpression';
    this.isPrefix = isPrefix;
    this.operator = operator;
    this.operand = operand;
  }
}

export class VariableDeclaration {
  constructor({kind, declarators}) {
    if (kind === undefined || ["var","let","const"].indexOf(kind) === -1) {
      throw new TypeError('Field "kind" of VariableDeclaration constructor is of incorrect type (expected one of {"var", "let", "const"})');
    }
    if (declarators === undefined || !Array.isArray(declarators) || declarators.some(f => f === undefined || f.type !== 'VariableDeclarator')) {
      throw new TypeError('Field "declarators" of VariableDeclaration constructor is of incorrect type (expected [VariableDeclarator])');
    }
    this.type = 'VariableDeclaration';
    this.kind = kind;
    this.declarators = declarators;
  }
}

export class VariableDeclarationStatement {
  constructor({declaration}) {
    if (declaration === undefined || declaration.type !== 'VariableDeclaration') {
      throw new TypeError('Field "declaration" of VariableDeclarationStatement constructor is of incorrect type (expected VariableDeclaration)');
    }
    this.type = 'VariableDeclarationStatement';
    this.declaration = declaration;
  }
}

export class VariableDeclarator {
  constructor({binding, init}) {
    if (binding === undefined || (binding.type !== 'BindingIdentifier') && ((binding.type !== 'ArrayBinding') && (binding.type !== 'ObjectBinding'))) {
      throw new TypeError('Field "binding" of VariableDeclarator constructor is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding})');
    }
    if (init === undefined || init !== null && (isNotExpression(init))) {
      throw new TypeError('Field "init" of VariableDeclarator constructor is of incorrect type (expected null or Expression)');
    }
    this.type = 'VariableDeclarator';
    this.binding = binding;
    this.init = init;
  }
}

export class WhileStatement {
  constructor({test, body}) {
    if (isNotExpression(test)) {
      throw new TypeError('Field "test" of WhileStatement constructor is of incorrect type (expected Expression)');
    }
    if (isNotStatement(body)) {
      throw new TypeError('Field "body" of WhileStatement constructor is of incorrect type (expected Statement)');
    }
    this.type = 'WhileStatement';
    this.test = test;
    this.body = body;
  }
}

export class WithStatement {
  constructor({object, body}) {
    if (isNotExpression(object)) {
      throw new TypeError('Field "object" of WithStatement constructor is of incorrect type (expected Expression)');
    }
    if (isNotStatement(body)) {
      throw new TypeError('Field "body" of WithStatement constructor is of incorrect type (expected Statement)');
    }
    this.type = 'WithStatement';
    this.object = object;
    this.body = body;
  }
}

export class YieldExpression {
  constructor({expression}) {
    if (expression === undefined || expression !== null && (isNotExpression(expression))) {
      throw new TypeError('Field "expression" of YieldExpression constructor is of incorrect type (expected null or Expression)');
    }
    this.type = 'YieldExpression';
    this.expression = expression;
  }
}

export class YieldGeneratorExpression {
  constructor({expression}) {
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of YieldGeneratorExpression constructor is of incorrect type (expected Expression)');
    }
    this.type = 'YieldGeneratorExpression';
    this.expression = expression;
  }
}
